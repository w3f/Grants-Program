"use strict";(self.webpackChunkgrants=self.webpackChunkgrants||[]).push([[81597],{79211:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"docs/RFPs/bpf-contracts","title":"BPF-based ink! smart contracts","description":"This Request for Proposals is closed, meaning we are not looking for any more proposals on this topic at the moment.","source":"@site/docs/RFPs/bpf-contracts.md","sourceDirName":"docs/RFPs","slug":"/docs/RFPs/bpf-contracts","permalink":"/docs/RFPs/bpf-contracts","draft":false,"unlisted":false,"editUrl":"https://github.com/w3f/Grants-Program/edit/master/docs/RFPs/bpf-contracts.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"APPI: Auto-funded public P2P infrastructure","permalink":"/docs/RFPs/appi"},"next":{"title":"Candle auction smart contract","permalink":"/docs/RFPs/candle-auction"}}');var r=n(74848),i=n(28453);const o={},a="BPF-based ink! smart contracts",c={},l=[{value:"Project Description \ud83d\udcc4",id:"project-description-page_facing_up",level:2},{value:"eBPF as a WASM alternative",id:"ebpf-as-a-wasm-alternative",level:3},{value:"eBPF constraints",id:"ebpf-constraints",level:3},{value:"eBPF advantages",id:"ebpf-advantages",level:3},{value:"Previous work",id:"previous-work",level:3},{value:"Conclusion",id:"conclusion",level:3}];function h(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"bpf-based-ink-smart-contracts",children:"BPF-based ink! smart contracts"})}),"\n",(0,r.jsx)(t.admonition,{type:"danger",children:(0,r.jsxs)(t.p,{children:["This Request for Proposals is ",(0,r.jsx)(t.em,{children:"closed"}),", meaning we are not looking for any more proposals on this topic at the moment."]})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Status:"})," ",(0,r.jsx)(t.a,{href:"https://forum.polkadot.network/t/ebpf-contracts-hackathon/1084/13?u=david",children:"Closed"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Proposer:"})," ",(0,r.jsx)(t.a,{href:"https://github.com/takahser",children:"takahser"})]}),"\n"]}),"\n",(0,r.jsxs)(t.h2,{id:"project-description-page_facing_up",children:["Project Description ","\ud83d\udcc4"]}),"\n",(0,r.jsxs)(t.p,{children:["Substrate's ",(0,r.jsx)(t.a,{href:"https://docs.rs/crate/pallet-contracts/latest",children:"FRAME contracts pallet"})," allows for WASM-based smartcontracts on Substrate, written in ",(0,r.jsx)(t.a,{href:"https://github.com/paritytech/ink",children:"ink!"}),", a Rust-based ",(0,r.jsx)(t.a,{href:"https://wiki.haskell.org/Embedded_domain_specific_language",children:"eDSL"}),". WASM comes with a lot of advantages, such as high flexibility, tooling, a good compiler (",(0,r.jsx)(t.a,{href:"%5Bhttps://xxxwasmtime%5D(https://github.com/bytecodealliance/wasmtime)",children:"wasmtime"}),") and a lot of high level constructs. However, these features comes with a cost: complexity of the API and compiler implementation as well as impacts on performance. For example, Substrate does not embed the API for WASM VM due to its complexity."]}),"\n",(0,r.jsx)(t.h3,{id:"ebpf-as-a-wasm-alternative",children:"eBPF as a WASM alternative"}),"\n",(0,r.jsxs)(t.p,{children:["An alternative to WASM here would be ",(0,r.jsx)(t.a,{href:"https://ebpf.io/",children:"eBPF"}),", a technology for running sandboxed programs in an operating system kernel. It originated from BSD's ",(0,r.jsx)(t.a,{href:"https://www.freebsd.org/cgi/man.cgi?bpf",children:"BPF"})," that comes with a ",(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Permissive_software_license#:~:text=A%20permissive%20software%20license%2C%20sometimes,usually%20including%20a%20warranty%20disclaimer.",children:"permissive"})," open-source license and represents a Linux-compatible implementation thereof, that instead uses a ",(0,r.jsx)(t.a,{href:"https://www.lawinsider.com/dictionary/viral-open-source-license",children:"viral"})," open-source license."]}),"\n",(0,r.jsx)(t.h3,{id:"ebpf-constraints",children:"eBPF constraints"}),"\n",(0,r.jsx)(t.p,{children:"However, vanilla eBPF has some serious constraints:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"https://lld.llvm.org/",children:"LLD"})," can't link BPF code (LLD is the ",(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Linker_(computing)",children:"linker"})," contained in ",(0,r.jsx)(t.a,{href:"https://llvm.org/",children:"LLVM"})," which is the compiler framework that Rust's compiler ",(0,r.jsx)(t.code,{children:"rustc"})," relies on)."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"rustup"})," doesn't include any ",(0,r.jsx)(t.code,{children:"core"})," nor ",(0,r.jsx)(t.code,{children:"std"})," library for LLVM (and rustc)'s a upstream BPF targets (",(0,r.jsx)(t.code,{children:"bpfeb-unknown-none"})," and ",(0,r.jsx)(t.code,{children:"bpfel-unknown-none"}),")"]}),"\n",(0,r.jsxs)(t.li,{children:["Loops are ",(0,r.jsx)(t.a,{href:"https://lwn.net/Articles/740157/",children:"not fully supported"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["While 1) and 2) technically can be worked around by using ",(0,r.jsx)(t.a,{href:"https://github.com/aya-rs/bpf-linker",children:"bpf-linker"}),", 3) needs further research. Also, 2) will only work if loops are bound statically due to constraints within the LLVM backend. A viable solution here would be to replace this constraint by using ",(0,r.jsx)(t.a,{href:"https://github.com/paritytech/wasm-instrument/blob/b51701088e3d4f13b77047237a2480b488e6d099/src/gas_metering/mod.rs#L108",children:"gas metering"}),"."]}),"\n",(0,r.jsx)(t.h3,{id:"ebpf-advantages",children:"eBPF advantages"}),"\n",(0,r.jsx)(t.p,{children:"Despite the constraints, eBPF-based ink! smart contracts would be expected to have the following advantages over its WASM-based counterpart:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Simplicity: Due to its register-based instruction set it would be easier to compile"}),"\n",(0,r.jsx)(t.li,{children:"Efficiency and performance"}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"previous-work",children:"Previous work"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"https://forum.polkadot.network/u/Alex",children:"Alex"})," and ",(0,r.jsx)(t.a,{href:"https://forum.polkadot.network/u/pepyakin",children:"pepyakin"})," have attempted to use eBPF instead of WASM for ink! smart contracts when attending a hackathon. While they didn't manage to compile to BPF, their resources might be useful as a starting point:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["eBPF contracts ",(0,r.jsx)(t.a,{href:"https://forum.polkadot.network/t/ebpf-contracts-hackathon/1084/3",children:"hack report"})]}),"\n",(0,r.jsxs)(t.li,{children:["Version of ",(0,r.jsx)(t.a,{href:"https://github.com/pepyakin/substrate-seal-ebpf",children:"pallet-contracts that can run eBPF contracts"})]}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://github.com/athei/bpf-adder",children:"Example contract"})}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsx)(t.p,{children:"The goal of this RFP is to allow for eBPF-based smart contracts.\nTo summarize, the rough process should be:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["Compile Rust-based ink! smart contracts using ",(0,r.jsx)(t.a,{href:"https://github.com/qmonnet/rbpf",children:"rBPF"}),", returning an ",(0,r.jsx)(t.em,{children:"eBPF ELF file"})]}),"\n",(0,r.jsx)(t.li,{children:"Store the ELF file on-chain"}),"\n",(0,r.jsx)(t.li,{children:"Execute the ELF file within the eBPF VM that will convert it to machine code"}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var s=n(96540);const r={},i=s.createContext(r);function o(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);